namespace dependencies ;



class LoggerSpy specializes Logger {
  
  private wrapped : Logger  ;
  
  
  public setWrapped (   in wrappedObject: Logger  ) {
    this.wrapped = wrappedObject;

  }
  
  
  public datatype LogCallInfo {
    
    public messageValue : String  ;
  }
  
  public datatype LogMultipleCallInfo {
    
    public messagesValue : String [ * ]  ;
  }
  
  public datatype LogWithResultCallInfo {
    
    public messageValue : String  ;
    
    public enumValueValue : MyEnum  ;
    
    public parametersValue : Map <String, String>  ;
  }
  
  public LogCallInfos : LogCallInfo [ * ]  ;
  
  public LogMultipleCallInfos : LogMultipleCallInfo [ * ]  ;
  
  public LogWithResultCallInfos : LogWithResultCallInfo [ * ]  ;
  
  public Log (   in message: String  ) {
    let callInfo: LogCallInfo = new LogCallInfo (  );

    callInfo.messageValue = message;

    this.LogCallInfos->add ( callInfo );

    if ( this.wrapped != null ) {
      this.wrapped.Log ( message );

    } 

  }
  
  public LogMultiple (   in messages: String [ * ]  ) {
    let callInfo: LogMultipleCallInfo = new LogMultipleCallInfo (  );

    callInfo.messagesValue = messages;

    this.LogMultipleCallInfos->add ( callInfo );

    if ( this.wrapped != null ) {
      this.wrapped.LogMultiple ( messages );

    } 

  }
  
  public LogWithResult (   in message: String ,   in enumValue: MyEnum ,   in parameters: Map <String, String>  ) : Boolean  {
    let callInfo: LogWithResultCallInfo = new LogWithResultCallInfo (  );

    callInfo.messageValue = message;

    callInfo.enumValueValue = enumValue;

    callInfo.parametersValue = parameters;

    this.LogWithResultCallInfos->add ( callInfo );

    if ( this.wrapped != null ) {
      return this.wrapped.LogWithResult ( message, enumValue, parameters );

    } 

    return false;

  }
}